# -*- coding: utf-8 -*-
"""carga_mental_cero_laura_cabrales.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JsevAu-A_OZGQyamylgsS2MI2rP9vNUQ
"""

import streamlit as st
from datetime import date
import uuid
import locale
import json # Necesario para guardar y cargar datos
import os # Necesario para verificar si el archivo existe
import pandas as pd

# --- CONFIGURACI√ìN DE LA PERSISTENCIA ---
# Usaremos un archivo JSON para almacenar los datos en el servidor de Streamlit.
TASKS_FILE = "tasks_data.json"

# --- CONFIGURACI√ìN DEL IDIOMA (M√ÅS ROBUSTA) ---
# Establecer el locale a espa√±ol para que strftime use nombres de d√≠as y meses en espa√±ol.
# Se prueban varias configuraciones comunes para asegurar la compatibilidad en diferentes sistemas.
locales_to_try = ['es_ES.UTF-8', 'es_ES.utf8', 'es_ES', 'es']
for loc in locales_to_try:
    try:
        locale.setlocale(locale.LC_TIME, loc)
        break
    except locale.Error:
        continue

# --- CONFIGURACI√ìN DE LA P√ÅGINA ---
st.set_page_config(
    page_title="Organizador de Tareas: Carga Mental Cero",
    layout="wide",
    initial_sidebar_state="expanded"
)

# --- ESTILOS CSS PERSONALIZADOS ---

CAPTION_STYLE = """
<style>
/* Estilo para los subt√≠tulos de las listas de tareas y calendario, forzando color negro */
div[data-testid="stCaptionContainer"] {
    color: #000000 !important;
}
</style>
"""
st.markdown(CAPTION_STYLE, unsafe_allow_html=True)


# --- CONSTANTES DE CATEGOR√çA Y ESTILOS ---
CATEGORIES = {
    "üî¥ Urgente": {"color": "#FF4B4B", "label": "Urgente"},      # Rojo
    "üü† Importante": {"color": "#FFA500", "label": "Importante"},  # Naranja
    "üü° Pendiente": {"color": "#FFD700", "label": "Pendiente"}   # Amarillo/Dorado
}

# --- FUNCIONES DE CARGA/GUARDADO DE DATOS (PERSISTENCIA) ---

def load_tasks():
    """Carga las tareas desde el archivo JSON si existe."""
    if os.path.exists(TASKS_FILE):
        try:
            with open(TASKS_FILE, 'r') as f:
                tasks = json.load(f)

                # Convertir las cadenas de fecha ISO de vuelta a objetos date
                for task in tasks:
                    if task["date"]:
                        task["date"] = date.fromisoformat(task["date"])
                return tasks
        except json.JSONDecodeError:
            st.warning("El archivo de tareas est√° corrupto. Se ha iniciado con una lista vac√≠a.")
            return []
    return []

def save_tasks():
    """Guarda las tareas en el archivo JSON."""

    # Pre-procesar tareas: convertir objetos date a cadenas ISO para serializaci√≥n
    tasks_to_save = []
    for task in st.session_state.tasks:
        task_copy = task.copy()
        # La fecha se convierte a string solo si existe
        if task_copy["date"]:
            task_copy["date"] = task_copy["date"].isoformat()
        tasks_to_save.append(task_copy)

    with open(TASKS_FILE, 'w') as f:
        json.dump(tasks_to_save, f, indent=4)

# --- INICIALIZACI√ìN DEL ESTADO DE SESI√ìN ---
# Se utiliza el estado de sesi√≥n de Streamlit para almacenar las tareas de forma persistente
if 'tasks' not in st.session_state:
    st.session_state.tasks = load_tasks()

# --- FUNCIONES AUXILIARES ---

def remove_task(task_id):
    """Elimina una tarea por su ID y guarda los cambios."""
    st.session_state.tasks = [task for task in st.session_state.tasks if task["id"] != task_id]
    save_tasks() # Guardar despu√©s de eliminar

def add_task(description, category_key, due_date):
    """Agrega una nueva tarea y guarda los cambios."""
    if description:
        category_name = CATEGORIES[category_key]["label"]

        new_task = {
            "id": str(uuid.uuid4()),
            "description": description,
            "category": category_name,
            "category_key": category_key,
            "date": due_date # date object or None
        }
        st.session_state.tasks.append(new_task)
        st.session_state.new_task_description = ""
        st.success("¬°Tarea agregada exitosamente!")
        save_tasks() # Guardar despu√©s de agregar
    else:
        st.error("La descripci√≥n de la tarea no puede estar vac√≠a.")

def update_task_date(task_id, new_date):
    """Actualiza la fecha de una tarea por su ID."""
    for i, t in enumerate(st.session_state.tasks):
        if t["id"] == task_id:
            st.session_state.tasks[i]["date"] = new_date
            save_tasks() # Guardar despu√©s de actualizar
            return True
    return False

def move_task_to_calendar_callback(task_id):
    """
    Callback ejecutado al presionar 'Mover a Calendario'.
    Lee la fecha del st.date_input asociado y actualiza la tarea.
    """
    date_key = f"popover_date_{task_id}"
    new_date = st.session_state.get(date_key)

    if new_date:
        if update_task_date(task_id, new_date):
            # La modificaci√≥n del estado de sesi√≥n y el guardado disparar√°n el rerun de Streamlit.
            pass


# --- L√ìGICA DE CLASIFICACI√ìN ---

def get_tasks_by_status():
    """Clasifica las tareas en listas sin fecha y tareas con fecha (calendario)."""

    tasks_no_date = {data["label"]: [] for data in CATEGORIES.values()}
    tasks_with_date = []

    for task in st.session_state.tasks:
        cat_label = CATEGORIES[task["category_key"]]["label"]
        if task["date"] is None:
            tasks_no_date[cat_label].append(task)
        else:
            tasks_with_date.append(task)

    tasks_with_date.sort(key=lambda x: x["date"])

    return tasks_no_date, tasks_with_date

# --- UI: ENTRADA DE TAREAS (SIDEBAR) ---

with st.sidebar:
    st.title("‚ûï Organiza tu Carga Mental")
    st.markdown("---")

    st.header("Nueva Tarea")

    # 1. Descripci√≥n de la tarea
    description = st.text_input(
        "1. Describe la tarea:",
        key="new_task_description",
        placeholder="Ejemplo: Preparar informe mensual"
    )

    # 2. Nivel de Urgencia
    category = st.radio(
        "2. Nivel de urgencia:",
        options=CATEGORIES.keys(),
        index=1, # Por defecto 'Importante'
        horizontal=True,
        key="new_task_category"
    )

    # 3. Fecha espec√≠fica (Opcional)
    has_date = st.checkbox("¬øTiene fecha espec√≠fica?", key="has_date_checkbox")
    due_date = None
    if has_date:
        due_date = st.date_input("3. Elige la fecha:", min_value=date.today(), key="new_task_date")

    # Bot√≥n para agregar la tarea
    st.button(
        "Guardar Tarea",
        on_click=add_task,
        args=(description, category, due_date if has_date else None),
        type="primary",
        use_container_width=True
    )
    st.markdown("---")
    st.markdown("ü§ñ **Objetivo:** Disminuir tu carga mental al visualizar y clasificar tus compromisos.")

# --- UI: PANTALLA PRINCIPAL ---

# Obtener tareas clasificadas
tasks_no_date, tasks_with_date = get_tasks_by_status()

st.title("üìÖ Tablero de tareas de LaO")

# --- SECCI√ìN 1: TAREAS POR ASIGNAR (LISTAS POR CATEGOR√çA) ---

st.header("Lista de tareas pendientes (Sin fecha asignada)")
st.caption("Estas tareas necesitan que les asignes una fecha para moverlas al calendario.")

# Crear tres columnas para las listas de tareas
col1, col2, col3 = st.columns(3)

def display_task_list(column, category_label, tasks):
    """Muestra una lista de tareas en una columna con el estilo de su categor√≠a."""
    category_data = next((v for k, v in CATEGORIES.items() if v["label"] == category_label), None)
    color = category_data["color"] if category_data else "#CCCCCC"

    with column:
        # Estilo para el encabezado de la lista
        st.markdown(
            f"""
            <div style="background-color: {color}; padding: 10px; border-radius: 8px 8px 0 0; color: white; text-align: center; font-weight: bold;">
                {category_label.upper()} ({len(tasks)})
            </div>
            """,
            unsafe_allow_html=True
        )

        if not tasks:
            st.info("¬°No hay tareas en esta categor√≠a!")

        for task in tasks:
            # Contenedor principal de la tarea
            st.markdown(
                f"""
                <div style="border: 1px solid {color}; border-radius: 0 0 8px 8px; margin-top: -1px; padding: 10px; display: flex; justify-content: space-between; align-items: center;">
                    <span style="flex-grow: 1; margin-right: 10px;">{task['description']}</span>
                </div>
                """,
                unsafe_allow_html=True
            )

            # Contenedor para los botones (popover y eliminar)
            col_popover, col_btn_del = st.columns([4, 1])

            with col_btn_del:
                # Bot√≥n de eliminar
                st.button(
                    "üóëÔ∏è",
                    key=f"del_no_date_{task['id']}",
                    on_click=remove_task,
                    args=(task['id'],),
                    help="Eliminar tarea"
                )

            with col_popover:
                # Popover para mover al calendario
                with st.popover("üìÖ Asignar fecha", use_container_width=True):
                    # Input de fecha, cuyo valor se guarda en el estado de sesi√≥n
                    st.date_input(
                        "Selecciona una fecha para esta tarea:",
                        min_value=date.today(),
                        key=f"popover_date_{task['id']}"
                    )

                    # Bot√≥n que llama al callback para leer la fecha del input y mover la tarea
                    st.button(
                        "Mover a Calendario",
                        key=f"move_to_cal_{task['id']}",
                        on_click=move_task_to_calendar_callback,
                        args=(task['id'],),
                        type="primary",
                        use_container_width=True
                    )

# Mostrar las tres listas
display_task_list(col1, "Urgente", tasks_no_date["Urgente"])
display_task_list(col2, "Importante", tasks_no_date["Importante"])
display_task_list(col3, "Pendiente", tasks_no_date["Pendiente"])

st.markdown("---")

# --- SECCI√ìN 2: CALENDARIO (TAREAS ASIGNADAS) ---

st.header("üóìÔ∏è Calendario")
# Se incluye el subt√≠tulo din√°mico con el color de letra forzado a negro
st.caption(f"Tienes **{len(tasks_with_date)}** tareas programadas.")

if not tasks_with_date:
    st.info("¬°No tienes tareas con fecha espec√≠fica a√∫n! Agr√©galas o as√≠gnales una fecha desde las listas.")
else:
    # Agrupar las tareas por fecha
    tasks_by_date = {}
    for task in tasks_with_date:
        # Formatear la fecha a un string legible y capitalizar la primera letra.
        # Gracias a la configuraci√≥n robusta de locale arriba, esto deber√≠a salir en espa√±ol.
        date_str = task["date"].strftime("%A, %d de %B de %Y").capitalize()
        if date_str not in tasks_by_date:
            tasks_by_date[date_str] = []
        tasks_by_date[date_str].append(task)

    for date_str, tasks in tasks_by_date.items():
        # Ordenar tareas dentro del d√≠a por nivel de urgencia para destacar la m√°s importante
        tasks.sort(key=lambda t: list(CATEGORIES.keys()).index(t['category_key']))
        top_color = CATEGORIES[tasks[0]['category_key']]['color']

        # Expander (el contenedor del d√≠a)
        with st.expander(f"**{date_str}** ({len(tasks)} Tareas)", expanded=True):
            # Inyectar CSS para el borde del expander
            st.markdown(
                f'<style>.stExpanderDetails {{ border-left: 5px solid {top_color}; padding-left: 10px; }}</style>',
                unsafe_allow_html=True
            )
            for task in tasks:
                color = CATEGORIES[task["category_key"]]["color"]

                # Dise√±o de tarjeta para cada tarea en el calendario
                col_desc, col_complete, col_btn_del = st.columns([4, 1, 1])

                with col_desc:
                    # Tarjeta de descripci√≥n con barra lateral de color
                    st.markdown(
                        f"""
                        <div style="background-color: #f0f2f6; border-left: 5px solid {color}; padding: 10px; margin-bottom: 5px; border-radius: 4px; display: flex; align-items: center;">
                            <strong style="margin-right: 10px;">{task['category_key'].split(' ')[0]}</strong>
                            <span>{task['description']}</span>
                        </div>
                        """,
                        unsafe_allow_html=True
                    )

                # --- BOT√ìN: MARCAR COMO COMPLETADA ---
                with col_complete:
                    st.button(
                        "‚úÖ",
                        key=f"complete_{task['id']}",
                        on_click=remove_task,
                        args=(task['id'],),
                        help="Marcar como realizada (Completar)",
                        type="secondary"
                    )

                with col_btn_del:
                    # --- BOT√ìN: ELIMINAR TAREA ---
                    st.button(
                        "üóëÔ∏è",
                        key=f"del_date_{task['id']}",
                        on_click=remove_task,
                        args=(task['id'],),
                        help="Eliminar tarea"
                    )